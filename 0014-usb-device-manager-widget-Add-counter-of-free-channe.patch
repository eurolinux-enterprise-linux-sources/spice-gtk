From 412962d94e9082ebfadbadc37bc4e77eb52a28fd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Fabiano=20Fid=C3=AAncio?= <fidencio@redhat.com>
Date: Tue, 19 Jan 2016 22:27:28 +0100
Subject: [PATCH 14/17] usb-device-{manager,widget}: Add counter of free
 channels

As the message showed when the last usbredir channel is taken can be a
bit confusing, let's add a counter of free channels to the widget's
label.
In order to add the counter, a new property for SpiceUsbDeviceManager
was introduced ("free-channels").

Related: rhbz#1298772

(cherry picked from commit 5166f891e566586bffcdc21b4b7386bf260bedc9)
---
 gtk/usb-device-manager.c | 29 +++++++++++++++++++++++++++++
 gtk/usb-device-widget.c  | 23 ++++++++++++++++++-----
 2 files changed, 47 insertions(+), 5 deletions(-)

diff --git a/gtk/usb-device-manager.c b/gtk/usb-device-manager.c
index 5013b6c..8a78b2d 100644
--- a/gtk/usb-device-manager.c
+++ b/gtk/usb-device-manager.c
@@ -89,6 +89,7 @@ enum {
     PROP_AUTO_CONNECT,
     PROP_AUTO_CONNECT_FILTER,
     PROP_REDIRECT_ON_CONNECT,
+    PROP_FREE_CHANNELS,
 };
 
 enum
@@ -411,6 +412,20 @@ static void spice_usb_device_manager_get_property(GObject     *gobject,
     case PROP_REDIRECT_ON_CONNECT:
         g_value_set_string(value, priv->redirect_on_connect);
         break;
+    case PROP_FREE_CHANNELS: {
+        int free_channels = 0;
+#if USE_USBREDIR
+        int i;
+        for (i = 0; i < priv->channels->len; i++) {
+            SpiceUsbredirChannel *channel = g_ptr_array_index(priv->channels, i);
+
+            if (!spice_usbredir_channel_get_device(channel))
+                free_channels++;
+        }
+#endif
+        g_value_set_int(value, free_channels);
+        break;
+    }
     default:
         G_OBJECT_WARN_INVALID_PROPERTY_ID(gobject, prop_id, pspec);
         break;
@@ -569,6 +584,20 @@ static void spice_usb_device_manager_class_init(SpiceUsbDeviceManagerClass *klas
                                     pspec);
 
     /**
+     * SpiceUsbDeviceManager:n-free-channels:
+     *
+     * Get a list of avaialable channels for redirecting USB devices.
+     */
+    pspec = g_param_spec_int("free-channels", "Free channels",
+               "The number of available channels for redirecting USB devices",
+               0,
+               G_MAXINT,
+               0,
+               G_PARAM_READABLE);
+    g_object_class_install_property(gobject_class, PROP_FREE_CHANNELS,
+                                    pspec);
+
+    /**
      * SpiceUsbDeviceManager::device-added:
      * @manager: the #SpiceUsbDeviceManager that emitted the signal
      * @device: #SpiceUsbDevice boxed object corresponding to the added device
diff --git a/gtk/usb-device-widget.c b/gtk/usb-device-widget.c
index 69c74b3..75ca1dd 100644
--- a/gtk/usb-device-widget.c
+++ b/gtk/usb-device-widget.c
@@ -72,6 +72,7 @@ struct _SpiceUsbDeviceWidgetPrivate {
     gchar *device_format_string;
     SpiceUsbDeviceManager *manager;
     GtkWidget *info_bar;
+    GtkWidget *label;
     gchar *err_msg;
     gsize device_count;
 };
@@ -181,7 +182,6 @@ static GObject *spice_usb_device_widget_constructor(
     SpiceUsbDeviceWidgetPrivate *priv;
     GPtrArray *devices = NULL;
     GError *err = NULL;
-    GtkWidget *label;
     gchar *str;
     int i;
 
@@ -197,12 +197,12 @@ static GObject *spice_usb_device_widget_constructor(
     if (!priv->session)
         g_error("SpiceUsbDeviceWidget constructed without a session");
 
-    label = gtk_label_new(NULL);
+    priv->label = gtk_label_new(NULL);
     str = g_strdup_printf("<b>%s</b>", _("Select USB devices to redirect"));
-    gtk_label_set_markup(GTK_LABEL (label), str);
+    gtk_label_set_markup(GTK_LABEL (priv->label), str);
     g_free(str);
-    gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.5);
-    gtk_box_pack_start(GTK_BOX(self), label, FALSE, FALSE, 0);
+    gtk_misc_set_alignment(GTK_MISC(priv->label), 0.0, 0.5);
+    gtk_box_pack_start(GTK_BOX(self), priv->label, FALSE, FALSE, 0);
 
     priv->manager = spice_usb_device_manager_get(priv->session, &err);
     if (err) {
@@ -396,6 +396,19 @@ static gboolean spice_usb_device_widget_update_status(gpointer user_data)
 {
     SpiceUsbDeviceWidget *self = SPICE_USB_DEVICE_WIDGET(user_data);
     SpiceUsbDeviceWidgetPrivate *priv = self->priv;
+    gchar *str, *markup_str;
+    const gchar *free_channels_str;
+    int free_channels;
+
+    g_object_get(priv->manager, "free-channels", &free_channels, NULL);
+    free_channels_str = ngettext(_("Select USB devices to redirect (%d free channel)"),
+                                 _("Select USB devices to redirect (%d free channels)"),
+                                 free_channels);
+    str = g_strdup_printf(free_channels_str, free_channels);
+    markup_str = g_strdup_printf("<b>%s</b>", str);
+    gtk_label_set_markup(GTK_LABEL (priv->label), markup_str);
+    g_free(markup_str);
+    g_free(str);
 
     priv->device_count = 0;
     gtk_container_foreach(GTK_CONTAINER(self), check_can_redirect, self);
-- 
2.10.0

